## function to calculate the least-cost paths between locations 

lcp_site <- function (x,
                      target,
                      radius = 200,
                      basemap,
                      bound_box,
                      resolution=10,
                      lines=FALSE,
                      recalculate=FALSE,
                      transition_name,
                      rad,
                      dirs=16,
                      midpoint=FALSE){
  
  #get the required libraries
  require(sf)
  require(tidyr)
  require(dplyr)
  require(raster)
  require(ggplot2)
  require(gdistance)
  require(nngeo)
  require(fasterize)
  require(reshape2)
  
  # x is the sf dataframe with the coordinates for the sites of interest. This dataframe must have the column 'site_id' to specify the name of each site. 
  # target is a sf point data.frame that has the target site to estimate the distance to
  # radius is the radius around the sites that will be used to set up a dynamic 
  # basemap is a sf polygon that shows the coast. This will be generated by the code unless otherwise specified. 
  # bound_box is a polygon that is used to trim the basemap
  # matrix out is a logical determining whether a distance matrix will be returned (default - TRUE) or a data.frame (FALSE)
  # resolution is the resolution in km for the transition object. Note that for very large scales this should be larger (default 10 km). 
  # lines logical specifying whether you want to extract the full paths as sf linestrings (default is FALSE)
  # recalculate is a logical as to whether the transition object (slowest part of the process should force recalculated)
  # transition_name - this is a name used to create the transition object and check to see if it should be recalculated. Note that the resolution is appended at the end of this name (e.g., atlantic_arctic_25km)
  # rad is the 'radius' searching funciton provided to coord_bump 
  # dirs is the 'directions' for the transition object. 
  # midpoint - when making the dynamic projection, should it be the geographic center or the centroid weighted by points
  
  #latitude and longitude projection 
  latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
  
  #Data check
  if(sum(names(x)%in%"site_id")!=1){stop("a column with the name 'site_id' must be included to capture the site name")}
  
  #load basemap for the least-cost path analysis
  if(is.null(basemap)){
    
    require(rnaturalearth)
    require(rnaturalearthhires)
    
    basemap <- rbind(ne_states(country = "Canada",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="Canada"),
                     ne_states(country = "United States of America",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="USA"))%>%st_union()%>%st_as_sf()
    
  }
  
  #make sure data is set to the projection used in the analysis
  x = x%>%st_transform(latlong)
  
  #check to see if the 
  trans_check <- file.exists(paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
  
  #create dynamic projection to set the boundaries of the least-cost path analysis
  
  if(midpoint){
    
    pts_center <- x%>%
                  st_bbox()%>% 
                  st_as_sfc()%>%
                  st_centroid()%>%
                  st_transform(latlong)%>%
                  suppressWarnings()%>%
                  suppressMessages()
    
  }else{
    
  pts_center <- x%>%
    summarise()%>%
    st_centroid()%>%
    st_transform(latlong)%>%
    suppressWarnings()%>%
    suppressMessages()
  }
  
  aeqd <- sprintf("+proj=aeqd +lat_0=%s +lon_0=%s +x_0=0 +y_0=0",
                  st_coordinates(pts_center)[2], st_coordinates(pts_center)[1])
  
  #set cropping buffer to create a transition object
  
  buffer_pts <- basemap%>%
                      st_transform(aeqd)%>%
                      st_bbox()%>%
                      st_as_sfc()%>%
                      st_buffer(100)%>% #50km buffer
                      st_bbox()%>%
                      st_as_sfc()%>%
                      st_sf() 
  
  #create raster at km scale set to 'resolution' parameter that can be used to develop the transition object
  r=suppressWarnings(raster(raster::extent(buffer_pts),res=resolution*1000,crs=aeqd)%>%projectRaster(.,crs=latlong))
  
  coast <- basemap%>%st_intersection(bound_box)
  
  ind <- r%>%
    fasterize(coast,.)%>%
    values(.)%>%
    as.data.frame()%>%
    rename(val=1)%>%
    mutate(val=is.na(val))%>%
    pull(val)
  
  #set raster value for the transition matrix
  r[] <- 0 #land - no conductance
  r[ind] <- 1 #water (note set to 1, if you set to 10 you change the costDistance calculation)
  
  #raster used to ensure the sample sites are in water
  r2 <- r
  r2[] <- 10 #land
  r2[ind] <- -10 #water
  
  #adjust coordinates so they are in the water. 
  
  message("Adjusting sites into water")
  
  samplesite_adjusted <- x%>%
    mutate(site_id=factor(site_id,levels=c(x$site_id)))%>% #this will enforce the order of sample sites onto the grouping
    as.data.frame()%>%
    group_by(site_id)%>%
    do(coord_bump(.,r2,radius=rad))%>%
    ungroup()%>%
    mutate(site_id=as.character(site_id))%>%
    left_join(.,x)%>%
    st_as_sf(coords=c("lon_a","lat_a"),crs=latlong,remove=FALSE)
  
  #calculate the offset between the recorded location and the location that the site was bumped to. This can be added to the distance for that site to any other site
  samplesite_adjusted$offset=9999 #placeholder for the distances 
  
  for(i in samplesite_adjusted$site_id){
    
    site <- samplesite_adjusted%>%filter(site_id == i)
    
    samplesite_adjusted[samplesite_adjusted$site_id == i,"offset"] <- st_distance(site,st_as_sf(data.frame(site),coords=c("lon","lat"),crs=st_crs(site)))%>%
      as.numeric()/1000#distance in km
    
    rm(site)
    
  }
  
  ## create row index that can be used for matching
  samplesite_adjusted$ind <- 1:nrow(samplesite_adjusted)
  
  #create the transition layer for distance calculations if required
  if(!trans_check | recalculate){
    
    message("Creating transition layer. This can take some time. ")
    
    trans <- transition(r,transitionFunction = min,directions=dirs)%>%
      geoCorrection(.,type="c",multpl = FALSE)
    
    #save the transition object
    if(!dir.exists("data/transition objects/")){dir.create("data/transition objects/")}
    
    save(trans,file=paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
    
  } else {load(paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))} #end the contextual if for the transition object. 
  
  ## Least-cost path analysis
  
  target_sp <- target%>%
               st_transform(st_crs(samplesite_adjusted))%>%
               as_Spatial()
  
  lcp_out <- data.frame()
  
  for(i in samplesite_adjusted$site_id){
    
    message(paste("Working on ",i,": ",which(i==samplesite_adjusted$site_id)," of ",nrow(samplesite_adjusted)))
    
    lcp_dist <- costDistance(trans,
                             samplesite_adjusted%>%
                               filter(site_id == i)%>%
                               as_Spatial,
                             target_sp)%>%
                as.numeric()/1000
    
    message(paste(round(lcp_dist,2),"km"))
    
    lcp_out <- rbind(lcp_out,data.frame(site_id=i,
                                        dist=lcp_dist))
    
  }
  
  
  ## Least-cost path lines
  if(lines){
    
    message("Extracting linestrings")
    
    nb.loc <- nrow(samplesite_adjusted)
    path <- list()
    comb <- combn(1:nb.loc, 2)
    
    pairwise_lines <- NULL
    pb <- txtProgressBar(min = 0, max = ncol(comb), style = 3)
    for (i in 1:nrow(samplesite_adjusted)) {
      
      origin <- target_sp
      goal <- samplesite_adjusted[i,]%>%as_Spatial()
      temp <- gdistance::shortestPath(trans, origin, goal, 
                                      output = "SpatialLines")
      

      line_coords <- data.frame(temp@lines[[1]]@Lines[[1]]@coords)
      
      temp_sf <- st_as_sf(line_coords,coords=c("x","y"),crs=latlong)%>%
        summarise(do_union = FALSE) %>%
        st_cast("LINESTRING") %>%
        mutate(origin = "SAB",
               dest = samplesite_adjusted[i,]%>%pull(site_id),
               len = nrow(line_coords))%>%
        dplyr::select(origin,dest,len,geometry)
  
      pairwise_lines <- rbind(pairwise_lines,temp_sf)
      
      setTxtProgressBar(pb, i)
      
    } #end for (i in 1:nrow(samplesite_adjusted))
    
  } #end if(lines)
  
 
  if(lines){
    
    temp <- output
    
    output <- list()
    output[[1]] <- lcp_out
    output[[2]] <- pairwise_lines
    
    
  }
  
  if(!lines){output <- lcp_out}
  
  #end function and return output
  return(output)
  
}