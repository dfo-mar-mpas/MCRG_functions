## function to create transition matrices 

trans_gen <- function (basemap,
                      bound_box,
                      resolution=10,
                      transition_name,
                      dirs=16,
                      recalculate=FALSE){
  
  #get the required libraries
  require(sf)
  require(tidyr)
  require(dplyr)
  require(raster)
  require(ggplot2)
  require(gdistance)
  require(nngeo)
  require(fasterize)
  require(reshape2)
  
  # basemap is a sf polygon that shows the coast. This will be generated by the code unless otherwise specified. 
  # bound_box is a bounding box that is used to trim the basemap
  # resolution is the resolution in km for the transition object. Note that for very large scales this should be larger (default 10 km). 
  # transition_name - this is a name used to create the transition object and check to see if it should be recalculated. Note that the resolution is appended at the end of this name (e.g., atlantic_arctic_25km)
  # dirs is the 'directions' for the transition object. 
  #  recalculate is a logical as to whether the transition object (slowest part of the process should force recalculated)
  
  #latitude and longitude projection 
  latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
  
  #load basemap for the least-cost path analysis
  if(is.null(basemap)){
    
    require(rnaturalearth)
    require(rnaturalearthhires)
    
    basemap <- rbind(ne_states(country = "Canada",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="Canada"),
                     ne_states(country = "United States of America",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="USA"))%>%st_union()%>%st_as_sf()
    
  }
  
  #check to see if the 
  trans_check <- file.exists(paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
  
  #create dynamic projection to set the boundaries of the least-cost path analysis
  
    pts_center <- bound_box%>%
                  st_as_sfc()%>%
                  st_centroid()%>%
                  st_transform(latlong)

  aeqd <- sprintf("+proj=aeqd +lat_0=%s +lon_0=%s +x_0=0 +y_0=0",
                  st_coordinates(pts_center)[2], st_coordinates(pts_center)[1])
  
  bound_box_aeqd <- bound_box%>%st_transform(aeqd)
  
 
  #create raster at km scale set to 'resolution' parameter that can be used to develop the transition object
  r=suppressWarnings(raster(raster::extent(bound_box_aeqd),res=resolution*1000,crs=aeqd)%>%projectRaster(.,crs=latlong))
  
  coast <- basemap%>%
           st_intersection(bound_box%>%st_as_sfc())
  
  ind <- r%>%
    fasterize(coast,.)%>%
    values(.)%>%
    as.data.frame()%>%
    rename(val=1)%>%
    mutate(val=is.na(val))%>%
    pull(val)
  
  #set raster value for the transition matrix
  r[] <- 0 #land - no conductance
  r[ind] <- 1 #water (note set to 1, if you set to 10 you change the costDistance calculation)
  
  #raster used to ensure the sample sites are in water
  r2 <- r
  r2[] <- 10 #land
  r2[ind] <- -10 #water
  
  #create the transition layer for distance calculations if required
  if(!trans_check | recalculate){
    
    message("Creating transition layer. This can take some time. ")
    
    trans_d <- transition(r,transitionFunction = min,directions=dirs)%>%
      geoCorrection(.,type="c",multpl = FALSE)
    
    #save the transition object
    if(!dir.exists("data/transition objects/")){dir.create("data/transition objects/")}
    
    save(trans_d,file=paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
    
  } else {load(paste0("data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))} #end the contextual if for the transition object. 
  
  return(trans)
  
}

lcp_otn_pair <- function (x,
                          trans_d,
                          lines=FALSE,
                          basemap_d,
                          sld_check=TRUE){
  
  #get the required libraries
  require(sf)
  require(tidyverse)
  require(raster)
  require(gdistance)
  require(reshape2)
  require(purrr)
  
  # x is a dataframe that contains 'lon' & 'lat' to denote where a animal was detected and 'lon_dep' and 'lat_dep' to denote where it was tagged
  # trans_d is the transition object to be used in the distance calculation. These are made in the lcp_site function but may need to be calculated manually
  # lines logical specifying whether you want to extract the full paths as sf linestrings (default is FALSE)
  # dirs is the 'directions' for the transition object. 
  # basemap_d is the basemap for the coast projected the same as x that was used to generate the transition object
  # sld_check - logical denoting whether to do staightline distances where possible. 
  
  #latitude and longitude projection 
  latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
  
  #create dynamic projection to set the boundaries of the least-cost path analysis
  
  pts_center <- rbind(x[,c("lon","lat")],
                      x[,c("lon_dep","lat_dep")]%>%rename(lat=lat_dep,lon=lon_dep))%>%
    st_as_sf(coords=c("lon","lat"),crs=latlong)%>%
    st_bbox()%>%
    st_as_sfc()%>%
    st_centroid()%>%
    st_transform(latlong)
  
  aeqd <- sprintf("+proj=aeqd +lat_0=%s +lon_0=%s +x_0=0 +y_0=0",
                  st_coordinates(pts_center)[2], st_coordinates(pts_center)[1])
  
  if(!exists("trans_d", envir = .GlobalEnv, inherits = FALSE)){stop("Must supply a transition object for calculation")}
  
  ## Least-cost path analysis
  
  #set up the inputs - this doesn't need to be long just pre-setting up all the peices. 
  start_sf <- x%>%st_as_sf(coords=c("lon_dep","lat_dep"),crs=latlong)
  start_locs <- start_sf%>%as_Spatial()
  start_proj <- st_transform(start_sf, aeqd)
  coords_start <- st_coordinates(start_sf)
  
  end_sf <- x%>%st_as_sf(coords=c("lon","lat"),crs=latlong)
  end_locs <- end_sf%>%as_Spatial()
  end_proj   <- st_transform(end_sf, aeqd)
  coords_end   <- st_coordinates(end_sf)
  
  #check for straight lines 
  if(sld_check){
    
    straight_lines <- st_sf(
      geometry = st_sfc(
        mapply(function(x1, y1, x2, y2) {
          st_linestring(matrix(c(x1, y1, x2, y2),
                               ncol = 2, byrow = TRUE))
        },
        coords_start[,1], coords_start[,2],
        coords_end[,1], coords_end[,2],
        SIMPLIFY = FALSE),
        crs = latlong
      )
    )
    
    intersects_land <- st_intersects(straight_lines, basemap, sparse = FALSE)[,1]
    
    no_land_between <- !intersects_land
    
    message(paste0(sum(no_land_between)," of ",nrow(start_sf)," (",round(sum(no_land_between)/nrow(start_sf)*100,2), "%) paths have no land barrier."))
    
  }else{ #if you don't want to use the straight line distances.
    no_land_between = NULL
    intersects_land = rep(TRUE,nrow(x))
  }
  
  
  #Least cost path analysis
  
  dist_vec <- numeric(nrow(x)) #pre-allocate the vector
  
  if (sld_check) {
    
    if (any(no_land_between)) { #points that can be a least cost path 
      
      dist_vec[no_land_between] <-
        as.numeric(
          st_distance(
            start_proj[no_land_between, ],
            end_proj[no_land_between, ],
            by_element = TRUE
          )
        ) / 1000
    }
    
    if (any(!no_land_between)) { #are there point pairs that need a least cost path analysis
      
      dist_vec[!no_land_between] <-
        diag(
          costDistance(
            trans_d,
            start_locs[!no_land_between, ],
            end_locs[!no_land_between, ]
          )
        ) / 1000
    }
    
  }# end sld_check if
  
  #add the data to the output data.frame()  
  x$tag_dist <- dist_vec
  
  
  ## Least-cost path lines
  
  if (lines && sld_check) {
    
    straight_lines_sf <- st_sf(
      geometry = st_sfc(
        lapply(seq_len(nrow(coords_start)), function(i) {
          st_linestring(rbind(coords_start[i,], coords_end[i,]))
        }),
        crs = latlong
      )
    )
  }
  
  if (lines) {
    
    message("Extracting linestrings")
    
    pairwise_lines_list <- vector("list", nrow(start_locs))
    
    for (i in seq_len(nrow(start_locs))) {
      
      if (i %% 25 == 0) {
        message(sprintf("Line %d of %d (%.1f%%)",
                        i, nrow(start_locs),
                        100 * i / nrow(start_locs)))
      }
      
      # ðŸ”¹ If sld_check is TRUE and no land between â†’ use straight line
      if (sld_check && no_land_between[i]) {
        
        temp <- straight_lines_sf[i, ] %>%
          mutate(animal_id = x$animal_id[i])%>%
          st_transform(latlong)
        
      } else {
        
        origin <- start_locs[i, ]
        goal   <- end_locs[i, ]
        
        temp <- gdistance::shortestPath(
          trans_d,
          origin,
          goal,
          output = "SpatialLines"
        ) %>%
          st_as_sf() %>%
          st_set_crs(latlong)%>%
          mutate(animal_id = x$animal_id[i])
      }
      
      pairwise_lines_list[[i]] <- temp
    }
  }
  
  #stack the output
  pairwise_lines <- do.call(rbind, pairwise_lines_list)
  
  
  if(lines){
    
    output <- list()
    output[[1]] <- x
    output[[2]] <- pairwise_lines
    
    
  }
  
  if(!lines){output <- x}
  
  #end function and return output
  return(output)
  
}